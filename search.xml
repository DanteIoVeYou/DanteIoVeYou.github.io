<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux系统编程-4-浅谈C语言库函数和系统调用接口的关联</title>
      <link href="/2022/03/03/%E3%80%90Linux%E3%80%914.%E6%B5%85%E8%B0%88C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E8%81%94/"/>
      <url>/2022/03/03/%E3%80%90Linux%E3%80%914.%E6%B5%85%E8%B0%88C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E8%81%94/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们给出这样一张计算机的层级图：</p><p><img src="https://img-blog.csdnimg.cn/867d41bb627849b2b6a96ca300bcb965.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARGFudGVJb1ZlWW91,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>可以看到，整个计算机体系分为硬件层和软件层</p><p>而在软件层，我们又有内核层与用户层</p><p>操作系统是横亘在硬件与用户软件之间的一个软件，对下管理各种硬件，对上为用户软件提供服务。我们可以这样类比</p><table><thead><tr><th>用户</th><th>校长</th></tr></thead><tbody><tr><td>操作系统</td><td>辅导员</td></tr><tr><td>硬件</td><td>学生</td></tr></tbody></table><p>我们人要管理好硬件，那么就需要一个懂硬件的帮我们管理硬件，那就是操作系统</p><p>但是，为了保证安全，操作系统对人只会开放特定的接口，通过特定的接口，人才可以来对硬件进行特定的管理，这样的接口，就叫做<code>系统调用接口</code></p><p>然而，系统调用接口是比较复杂的，让人每次都使用系统调用接口去管理硬件也太烦了吧，于是，便有一些别有用心的人对于系统调用接口进行了<code>二次封装</code>，封装出了一些更加友好、人性化的接口来供人调用，例如：</p><ul><li>C语言库函数</li><li>命令行解释器</li><li>图形化界面</li></ul><p>总而言之，这张层级图解释了一切：</p><p><img src="https://img-blog.csdnimg.cn/4e680c7b959a42e2a555daeb415c81f1.bmp#pic_center" alt="在这里插入图片描述"></p><p>接下来，我们就以Linux操作系统为例，分别看一下系统调用接口和经过二次封装的C语言库函数对于<code>读/写</code>操作的方式</p><h1 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h1><blockquote><p>1.考察open， read, write, lseek， close等函数的使用，同时理解文件描述符<br>2.要求:<br>2.1 使用代码打开当前路径下的“bite”文件（如果文件不存在在创建文件），向文件当中写入“i like linux!”.<br>2.2 在从文件当中读出文件当中的内容， 打印到标准输出当中； 关闭文件描述符</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">&quot;bite&quot;</span>, O_WRONLY|O_CREAT, <span class="number">0644</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* buffer = <span class="string">&quot;i like linux\n&quot;</span>;</span><br><span class="line">  write(fd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">  close(fd);</span><br><span class="line">  fd = open(<span class="string">&quot;bite&quot;</span>, O_RDONLY, <span class="number">0644</span>);</span><br><span class="line">  <span class="keyword">char</span> output[<span class="number">128</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  read(fd, output, <span class="number">127</span>);</span><br><span class="line">  write(<span class="number">1</span>, output, <span class="built_in">strlen</span>(output));</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5e363786260c4ee7b7844871d0c05a79.png#pic_center" alt="在这里插入图片描述"></p><h1 id="C语言库函数"><a href="#C语言库函数" class="headerlink" title="C语言库函数"></a>C语言库函数</h1><blockquote><p>1.考察fopen, fread, fwrite, fseek, fclose等函数的使用<br>2.要求：<br>2.1使用代码打开当前路径下的“bite”文件（如果文件不存在在创建文件），向文件当中写入“linux so easy!”.<br>2.2 在从文件当中读出文件当中的内容， 打印到标准输出当中； 关闭文件流指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FILE* fp = fopen(<span class="string">&quot;bite&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* buffer = <span class="string">&quot;linux so easy\n&quot;</span>;</span><br><span class="line">  fwrite(buffer, <span class="number">1</span>, <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  fp = fopen(<span class="string">&quot;bite&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> output[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  fread(output, <span class="number">1</span>, <span class="number">128</span>, fp);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s&quot;</span>, output);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8ef8a182792545daa0e043c2c3dfefea.png#pic_center" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以看到，系统调用接口和C语言库函数都能完成读写操作，总的来说：</p><ol><li>在开发角度，操作系统对外表现成一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。</li><li>系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更上层用户或者开发者进行二次开发。</li></ol><p><img src="https://img-blog.csdnimg.cn/887a2568b72c4118afbea2aa35cad466.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARGFudGVJb1ZlWW91,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-3-浅谈文件描述符和重定向</title>
      <link href="/2022/02/26/%E3%80%90Linux%E3%80%913.%E6%B5%85%E8%B0%88%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2022/02/26/%E3%80%90Linux%E3%80%913.%E6%B5%85%E8%B0%88%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文件描述符是从0开始增长的整数，对于一个Linux进程而言，默认会打开0、1、2三个文件描述符，也就是打开三个文件<br>| 文件描述符 | 文件       |<br>| ———- | ———- |<br>| 0 标准输入 | 键盘文件   |<br>| 1 标准输出 | 显示器文件 |<br>| 2 标准错误 | 显示器文件 |</p><p>当我们用系统接口open打开新的文件时，新分配的文件描述符是<code>最小的未被分配的</code></p><h1 id="进程、文件和文件描述符"><a href="#进程、文件和文件描述符" class="headerlink" title="进程、文件和文件描述符"></a>进程、文件和文件描述符</h1><p>我们首先要明确这样一个概念：文件位于磁盘上时，当我们要操作文件时，实际上是创建了进程来操作文件</p><p>在进程控制块pcb所对应的结构体<code>task_struct</code>中，我们可以找到一个<code>files_struct</code>结构体的指针<code>files</code>，进程用这个结构体来管理自己打开的文件<br><img src="https://img-blog.csdnimg.cn/c5a323321b274fa69a8f910fdb3e6525.png#pic_center" alt="在这里插入图片描述"><br>转到定义:<br><img src="https://img-blog.csdnimg.cn/8c4cac6bbeb24412b5fdb22675464625.png" alt="在这里插入图片描述"><br>提起从0开始的整数，大家想到了什么？</p><p>数组下标！</p><p>我们发现，在<code>files_struct</code>，恰好有一个叫做<code>fd_array</code>的struct file*数组，而struct file 结构体我们一看，正是描述文件属性和方法的结构体：<br><img src="https://img-blog.csdnimg.cn/79a2a447475e47c589f505e9e73ff2e1.png" alt="在这里插入图片描述"><br>其中，<code>struct file_operations</code>定义了read、write等方法：<br><img src="https://img-blog.csdnimg.cn/16f4a9bd8ed94e0c92c17dcf07374f12.png" alt="在这里插入图片描述"><br>我们可以看到，函数指针是C语言结构体实现面向对象的方式</p><hr><p>另外值得一提的是，对于所有文件，不管是显示器文件，键盘文件，还是普通文件，file结构体中的file_operations中提供的函数指针方法看上去都是一样的</p><p>可能有人会问了，read一个键盘文件和打开一个网卡文件肯定用的方法不一样啊，怎么调用的都叫read</p><p>其实不然，调用read之后，read便会去下层调用具体的文件提供的read的方法，对于网卡来说，就是网卡驱动，驱动中含有具体的网卡的read方法</p><p>这样一来，在操作系统层面，所有文件的读取都在OS层被抽象化成了<code>read</code>，操作系统读一切的文件在OS层都是用的file_operations中的read</p><blockquote><p>以函数指针的形式，对底层及虚拟化，屏蔽底层硬件的差异，函数指针指向不同的底层的方法，使得上层就能以同样的视角看待文件，抽象出各个硬件的共性供操作系统直接用函数指针调用方法完成一切皆文件的特性</p></blockquote><hr><p>综上，文件描述符是数组fd_array的下标，每一个数组成员指向了一个文件的属性结构体，从而来管理一个具体的文件</p><p>Linux把进程打开的文件抽象成了0、1、2…等文件描述符，通过数组和数组下标的方式对文件进行管理</p><p>一图蔽只之：<br><img src="https://img-blog.csdnimg.cn/bf05a556693e45ea95c98436108d6619.png" alt="在这里插入图片描述"></p><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>既然进程根据文件描述符才能找到具体的文件，那么是不是只要我们修改文件描述符与文件的对应关系，就能偷梁换柱了呢？</p><p>当然！</p><p>我们知道，C语言的printf是向显示器打印，那么在系统层，printf一定是向文件描述符为1的文件进行写入操作</p><p>printf始终认为fd == 1 的文件是显示器文件，对，它就是咬准这一点的，对于fd == 1 到底指向什么文件，printf不关心</p><p>所以说，根据我们上面的一个规则：</p><blockquote><p>新分配的文件描述符是最小的未被分配的</p></blockquote><p>那么如果我们先关闭1号文件描述符，也就是标准输入</p><p>然后再创建并打开一个普通文件 file.txt，给file.txt分配的文件描述符就应该是1</p><p>再调用printf(“hello world”)</p><p>那么helloworld是打印在屏幕上，还是写入到file.txt里呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"><span class="comment">// 关闭1号文件描述符</span></span><br><span class="line">  close(<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 写的方式打开file.txt</span></span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_WRONLY|O_CREAT, <span class="number">0644</span>);    </span><br><span class="line"><span class="comment">// 向1号文件描述符写入</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;helloworld\n&quot;</span>);     </span><br><span class="line"><span class="comment">// 刷新缓冲区                                                          </span></span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="comment">// 关闭文件描述符    </span></span><br><span class="line">  close(fd);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>事实证明，helloworld写入到了file.txt中：</p><p><img src="https://img-blog.csdnimg.cn/e665e38114644281ab81faace2a23631.png#pic_center" alt="在这里插入图片描述"><br>这是什么？</p><p>重 ！ 定 ！ 向  ！</p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-2-快速入门gdb</title>
      <link href="/2022/02/13/%E3%80%90Linux%E3%80%912.%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8gdb/"/>
      <url>/2022/02/13/%E3%80%90Linux%E3%80%912.%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8gdb/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在VS系列的IDE中，我们习惯于图形化窗口的调试；而在linux的命令行下，我们则借助gdb这个工具来完成程序的调试</p><p>阅读完本文，你将了解：</p><ul><li>显示代码</li><li>打断点、跳转到断点</li><li>逐过程执行</li><li>逐语句执行</li><li>长显示变量信息</li><li>跳转到指定行</li><li>禁用断点</li><li>调试时更改变量</li></ul><h1 id="如何将源码编译成可调试的二进制文件"><a href="#如何将源码编译成可调试的二进制文件" class="headerlink" title="如何将源码编译成可调试的二进制文件"></a>如何将源码编译成可调试的二进制文件</h1><p>我们以前在编译一个C语言源文件mytest.c时，通常使用这条指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc mytest.c -o mytest</span><br></pre></td></tr></table></figure><p>顺利生成了可执行文件<code>mytest</code></p><p>如果我们直接使用gdb调试这个可执行文件，会发现没有调试信息：<br><img src="https://img-blog.csdnimg.cn/1adc4474f17d4e768b7c4e79fb7f7416.png#pic_center" alt="在这里插入图片描述"><br>这是为什么呢？</p><p>Linux中程序默认编译的时候</p><ul><li>默认生成的可执行程序是release版本的，不可调式</li></ul><p>所以</p><ul><li>需要调试，gcc编译时需要加 <code>-g</code> 参数，以debug方式发布程序，使得可执行文件带有调试信息–&gt;才可以被gdb追踪，调试，即：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc mytest.c -o mytest_debug -g</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/914015c4e7144aad9d56576db1045570.png#pic_center" alt="在这里插入图片描述"><br>我们还可以发现的是，debug版本的可执行文件比release版本的大一些，这就是因为添加了调试信息<br><img src="https://img-blog.csdnimg.cn/9f4e543766124bab9fad9f07defcec36.png#pic_center" alt="在这里插入图片描述"></li></ul><h1 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h1><p>首先给一下源文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt;= top; i++) &#123;</span><br><span class="line">                _sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please enter your data# &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;max);</span><br><span class="line">        <span class="keyword">int</span> _sum = sum(max);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1:%d\n&quot;</span>, _sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2:%d\n&quot;</span>, _sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3:%d\n&quot;</span>, _sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;4:%d\n&quot;</span>, _sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5:%d\n&quot;</span>, _sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;6:%d\n&quot;</span>, _sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先编译生成带调试信息的可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc mytest.c -o mytest_debug -g</span><br></pre></td></tr></table></figure><p>然后gdb调试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb mytest_debug</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>list/l</td><td>显示源代码（一次10行）</td></tr><tr><td>run/r</td><td>运行程序</td></tr><tr><td>next/n</td><td>逐过程执行</td></tr><tr><td>step/s</td><td>逐语句执行，可进入函数内</td></tr><tr><td>break/b 行号</td><td>在某一行设置断点</td></tr><tr><td>info break</td><td>查看断点信息</td></tr><tr><td>finish</td><td>执行到当前函数返回</td></tr><tr><td>print/p</td><td>打印表达式的值</td></tr><tr><td>set var</td><td>修改变量的值</td></tr><tr><td>continue</td><td>跳到下一个断点</td></tr><tr><td>delete breakpoints</td><td>删除所有断点</td></tr><tr><td>delete breakpoints n</td><td>删除序号为n的断点</td></tr><tr><td>disable breakpoints n</td><td>取消对序号为n的断点的追踪</td></tr><tr><td>enable breakpoints n</td><td>恢复对序号为n的断点的追踪</td></tr><tr><td>info breakpoints</td><td>打印设置的断点</td></tr><tr><td>display 变量名</td><td>长显示某变量</td></tr><tr><td>undisplay变量名</td><td>取消对某变量的长显示</td></tr><tr><td>until 行号</td><td>跳至某行</td></tr><tr><td>quit/q</td><td>退出gdb</td></tr></tbody></table><p>下面演示常用命令</p><h2 id="显示代码-l"><a href="#显示代码-l" class="headerlink" title="显示代码 l"></a>显示代码 l</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list/l 行号</span><br></pre></td></tr></table></figure><p>显示源代码，一次显示10行，再按回车会接着往下显示<br><img src="https://img-blog.csdnimg.cn/37b1039c1ad7417fba4fecd06dce451f.png" alt="在这里插入图片描述"></p><h2 id="运行程序-r"><a href="#运行程序-r" class="headerlink" title="运行程序 r"></a>运行程序 r</h2><p>我们开始调试，也就是要运行程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run/r</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/19e4e0febf38426986df974ca961628e.png#pic_center" alt="在这里插入图片描述"><br>我们发现，r之后，代码直接执行到了第14行的输入语句，并且输入之后程序直接结束，根本没有进行调试。原因是因为我们没有设置断点，如果设置了断点，r将会执行到第一个断点处停止，这样我们就能进行单步调试。</p><h2 id="设置、查看断点"><a href="#设置、查看断点" class="headerlink" title="设置、查看断点"></a>设置、查看断点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b 行号 <span class="comment">//设置断点</span></span><br><span class="line">info b <span class="comment">//查看断点</span></span><br></pre></td></tr></table></figure><p>我们在14、15、19行设置了断点<br><img src="https://img-blog.csdnimg.cn/d5138cb5966f4d74b7aa65c19e482b1d.png" alt="在这里插入图片描述"></p><h2 id="next单步逐过程调试"><a href="#next单步逐过程调试" class="headerlink" title="next单步逐过程调试"></a>next单步逐过程调试</h2><p>我们继续r执行程序，再n单步执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure><p>发现n没有让我们进入函数体内，这说明了n是逐过程调试<br><img src="https://img-blog.csdnimg.cn/a050b0d85cfe4695bbd611b336361749.png" alt="在这里插入图片描述"></p><h2 id="step逐语句调试"><a href="#step逐语句调试" class="headerlink" title="step逐语句调试"></a>step逐语句调试</h2><p>我们用s进入函数体内<br><img src="https://img-blog.csdnimg.cn/47af0c3bad53447ea5e74e10936db252.png" alt="在这里插入图片描述"></p><h2 id="finish执行到当前函数返回停下"><a href="#finish执行到当前函数返回停下" class="headerlink" title="finish执行到当前函数返回停下"></a>finish执行到当前函数返回停下</h2><p><code>finish</code><br><img src="https://img-blog.csdnimg.cn/843f3689cd3943c0a9ddbc5e0178751b.png" alt="在这里插入图片描述"></p><h2 id="c跳到下一个断点"><a href="#c跳到下一个断点" class="headerlink" title="c跳到下一个断点"></a>c跳到下一个断点</h2><p><code>c</code><br><img src="https://img-blog.csdnimg.cn/717ba302e0f440b695fcd9c0cb0f8eb4.png" alt="在这里插入图片描述"></p><h2 id="dispaly-长显示变量"><a href="#dispaly-长显示变量" class="headerlink" title="dispaly 长显示变量"></a>dispaly 长显示变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display 变量名</span><br><span class="line">undisplay 变量序号</span><br></pre></td></tr></table></figure><p>注意undisolay的是变量前面的序号<br><img src="https://img-blog.csdnimg.cn/6b12a8caebd94d46be38c9366eb2fdd4.png#pic_center" alt="在这里插入图片描述"></p><h2 id="打印表达式的值-p"><a href="#打印表达式的值-p" class="headerlink" title="打印表达式的值 p"></a>打印表达式的值 p</h2><p><code>p</code><br><img src="https://img-blog.csdnimg.cn/82b91fa6d282448084b140ace985283f.png#pic" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-1-防火墙命令</title>
      <link href="/2021/10/02/%E3%80%90Linux%E3%80%911.%E9%98%B2%E7%81%AB%E5%A2%99%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/10/02/%E3%80%90Linux%E3%80%911.%E9%98%B2%E7%81%AB%E5%A2%99%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们经常要让防火墙放行/堵住服务器各个端口，故今做一份总结</p><h1 id="常用防火墙命令"><a href="#常用防火墙命令" class="headerlink" title="常用防火墙命令"></a>常用防火墙命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看防火墙状态</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"><span class="comment">#列出放行的端口</span></span><br><span class="line">firewall-cmd --list -all</span><br><span class="line"><span class="comment">#查看80端口是否放行</span></span><br><span class="line">firewall-cmd --query-port=80/tcp</span><br><span class="line"><span class="comment">#永久放行80端口</span></span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line"><span class="comment">#永久堵住80端口</span></span><br><span class="line">firewall-cmd --remove-port=80/tcp --permanent</span><br><span class="line"><span class="comment">#重新加载</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service  </span><br><span class="line"><span class="comment">#启动防护墙</span></span><br><span class="line">systemctl start firewalld.service  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言-8-程序的编译与预处理操作</title>
      <link href="/2021/08/19/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%918.%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/08/19/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%918.%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p> 本文将详细介绍当你在VS中按下<code>ctrl+f5</code>或者linux命令行下输入<code>gcc 文件名</code>后计算机所执行的一系列操作，包括<strong>预处理</strong>、<strong>编译</strong>、<strong>汇编</strong>、<strong>链接</strong>，以及一些C语言的<strong>预处理指令</strong>的使用。 </p><h1 id="翻译过程"><a href="#翻译过程" class="headerlink" title="翻译过程"></a>翻译过程</h1><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>在ANSI C的任意一种实现中，存在2中不同的环境。第一种是翻译环境，负责将源代码转换成可执行的机器指令；第二种是执行环境，用于实际执行代码。*<a href="#r1">[1]</a>*</p><p>一个程序从源代码到可执行程序一共会经历四个过程，分别是<strong>预处理</strong>、<strong>编译</strong>、<strong>汇编</strong>、<strong>链接</strong>，每一步都承担了不同的任务。</p><p>以下是<strong>GCC and Make Compiling, Linking and Building C/C++ Applications</strong>           中的描述 <a href="#r2"><em>[2]</em></a>：</p><p>GCC compiles a C/C++ program into executable in 4 steps as shown in the above diagram. For example, a “gcc -o hello.exe hello.c” is carried out as follows:</p><p><strong>Pre-processing</strong>: via the GNU C Preprocessor (cpp.exe), which includes the headers (#include) and expands the macros (#define).</p><blockquote><p>cpp hello.c &gt; hello.i</p></blockquote><p>The resultant intermediate file “hello.i” contains the expanded source code.</p><p><strong>Compilation</strong>: The compiler compiles the pre-processed source code into assembly code for a specific processor.</p><blockquote><p>gcc -S hello.i</p></blockquote><p>The -S option specifies to produce assembly code, instead of object code. The resultant assembly file is “hello.s”.</p><p><strong>Assembly</strong>: The assembler (as.exe) converts the assembly code into machine code in the object file “hello.o”.</p><blockquote><p>as -o hello.o hello.s</p></blockquote><p><strong>Linker</strong>: Finally, the linker (ld.exe) links the object code with the library code to produce an executable file “hello.exe”.</p><blockquote><p>ld -o hello.exe hello.o …libraries…</p></blockquote><p>如图一、二、三所示：<br> <img src="https://img-blog.csdnimg.cn/694e87796144473fabaaa25943278302.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图一<center><br><p><img src="https://img-blog.csdnimg.cn/b907b4a379464fcca9a211136e4cbf94.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图二<center><br><p><img src="https://img-blog.csdnimg.cn/e8ecbb0228064c89bca99439d9f1b08c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图三（引用自[2]）<center><br>## 预处理<p>C预处理依赖C预处理器，C预处理器在程序执行之前查看程序（故称为预处理器）。根据程序中的预处理指令，预处理器把符号缩写替换成其表示的内容。预处理器可以包含程序所需的其他文件，可以选择让编译器选择性地查看某些代码（如<code>#if</code> <code>#endif</code>等）。</p><p>本质上而言，C预处理器是<strong>将一些文本转换成了另外一些的文本</strong>，所以C预处理器并不能看懂C语言。</p><blockquote><p>在预处理前，编译器必须对该程序进行一些翻译处理。<br>a）首先，编译器把源代码中出现的字符映射到源字符集。<br>b）第二，编译器定位每个反斜杠 ‘\‘ 后面跟着的换行符的实例，并删除他们。也就是说，将两个物理行（physical line）：<br><code>printf(&quot;That is wond\</code><br><code>erful!\n&quot;);</code><br>转化成一个逻辑行（logical line）：<br><code>printf(&quot;That is wonderful!\n&quot;);</code><br>注意，在这种场合下，换行符的概念是通过按下<strong>Enter键</strong>在源代码文件中换行所生成的字符，而不是指换行符 <strong>‘\n’</strong>。<br>c）编译器把文本划分为预处理记号序列、空白序列和注释序列。编译器将用一个空格字符替换每一条注释。如：<br><code>int /*It&#39;s an annotation*/ a; </code><br>变为<br><code>int a;</code></p></blockquote><p>预处理指令将在下面一节详细讲解</p><p>那么现在，让我们在Linux平台下测试一下当test.c源文件只经过预处理后生成的test.i有何特点。</p><p>test.c文件中，我们定义了标识符X，宏MAX，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(X,Y) ((X)&gt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> A = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">int</span> max = MAX(X,A);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>,max);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只进行预处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure><p>得到的test.i文件如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">4</span> <span class="string">&quot;test.c&quot;</span> <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> A = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">int</span> max = ((<span class="number">10</span>)&gt;(A)?(<span class="number">10</span>):(A));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>,max);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，在预处理阶段，标识符X与宏MAX所代表的一串字符被替换到了源文件中的X与MAX处。<br>值得注意的是，#define定义的标识符可以<strong>嵌套使用</strong>，例如上面的X作为了MAX的参数。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译的作用是将预处理完文件中的源代码转化成<strong>汇编代码</strong></p><p>我们在Linux平台下对 test.c 进行编译操作，使test.c源文件在编译完之后停止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.c</span><br></pre></td></tr></table></figure><p>得到的test.s文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.file<span class="string">&quot;test.c&quot;</span></span><br><span class="line">.section.rodata</span><br><span class="line">.LC0:</span><br><span class="line">.<span class="built_in">string</span><span class="string">&quot;max = %d\n&quot;</span></span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">subq$<span class="number">16</span>, %rsp</span><br><span class="line">movl$<span class="number">20</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">movl$<span class="number">10</span>, %eax</span><br><span class="line">cmpl$<span class="number">10</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">cmovge<span class="number">-4</span>(%rbp), %eax</span><br><span class="line">movl%eax, <span class="number">-8</span>(%rbp)</span><br><span class="line">movl<span class="number">-8</span>(%rbp), %eax</span><br><span class="line">movl%eax, %esi</span><br><span class="line">movl$.LC0, %edi</span><br><span class="line">movl$<span class="number">0</span>, %eax</span><br><span class="line">call<span class="built_in">printf</span></span><br><span class="line">movl$<span class="number">0</span>, %eax</span><br><span class="line">leave</span><br><span class="line">.cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident<span class="string">&quot;GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)&quot;</span></span><br><span class="line">.section.note.GNU-<span class="built_in">stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这其实就是 test.c 的汇编代码。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>我们将汇编代码文件与库函数文件进行链接，随即便能生成a.out的可执行文件。</p><p>在Linux环境下，<strong>stdio.h头文件</strong>包括在 <strong>/usr/include</strong> 路径下。</p><p>我们执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc-C test.c</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.out</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>运行结果如图四：</p><p><img src="https://img-blog.csdnimg.cn/f8e0a561084c476dae0f41c08b2630b1.PNG#pic_center" alt="在这里插入图片描述"></p><center>图四<center><br># 执行过程<p>程序的执行过程如下：</p><ol><li>程序载入内存</li><li>调用main函数</li><li>开始执行代码，开辟堆栈存放临时变量与返回地址，也可以使用静态内存</li><li>程序正常终止或意外终止</li></ol><h1 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h1><h2 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h2><p>C语言内置了一些预定义符号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__FILE__ <span class="comment">//进行编译的源文件</span></span><br><span class="line">__LINE__ <span class="comment">//文件当前的行号</span></span><br><span class="line">__DATE__ <span class="comment">//文件被编译的日期 </span></span><br><span class="line">__TIME__ <span class="comment">//文件被编译的时间</span></span><br><span class="line">__STDC__ <span class="comment">//如果编译器遵循ANSI C，其值为1，否则未定义</span></span><br></pre></td></tr></table></figure><p>请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在这里插入代码片</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%d\n%s\n%s\n&quot;</span>, __FILE__,__LINE__, __DATE__,__TIME__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图五所示：</p><p><img src="https://img-blog.csdnimg.cn/2e665764cd41492faf17462ff53c545f.PNG#pic_center" alt="在这里插入图片描述"></p><center>图五<center><br>## #define定义宏常量<p>#define能够定义标识符，在预处理阶段预处理器会将标识符的内容进行替换<br>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000</span></span><br></pre></td></tr></table></figure><h2 id="define定义宏函数"><a href="#define定义宏函数" class="headerlink" title="#define定义宏函数"></a>#define定义宏函数</h2><p>#define能够定义宏，宏的声明方式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> name(parament-list) stuff</span></span><br></pre></td></tr></table></figure><p>其中，parament-list是一个由逗号隔开的参数列表，里面的参数能够出现在stuff中。</p><p>注意，参数列表的左括号必须与name紧邻。如果两者之间有任何空白存在，参数列表就会被解释成stuff的一部分。</p><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(X,Y) ((X)&gt;(Y)?(X):(Y))</span></span><br></pre></td></tr></table></figure><p>这个宏用来求两数之间的较大者</p><p><strong>以下还有3条注意事项</strong></p><ol><li>我们在定义宏的时候，最好把每一个参数用()括起来，最后，把整个stuff用()括起来</li><li>宏的参数中可以出现其他#define定义的标识符，但是宏不能递归</li><li>当预处理器搜索#define定义的符号时，字符串常量（包含在“ ”中）的内容并不被搜索，替代。</li></ol><p>我们来看下面一段代码解释一下第一条注意事项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUL(X) X * X</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = MUL(<span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, MUL(<span class="number">3</span> + <span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图六：<br><img src="https://img-blog.csdnimg.cn/8ae950c82aa74430a03f77579a082d54.PNG#pic_center" alt="在这里插入图片描述"></p><center>图五<center><br><p>我们的本意是想要对于3+2先进行加法，后进行平方，得到25</p><p>但是，实际上的结果是这样进行运算的：</p><blockquote><p>3 + 2 * 2 +3</p></blockquote><p>得到11</p><p>所以，我们在书写宏的时候，最好把每一个参数用()括起来，最后，把整个stuff用()括起来，<strong>避免在使用宏时参数中的操作符或临近操作符之间不可预料的相互作用</strong><br>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUL(X) ((X) * (X))</span></span><br></pre></td></tr></table></figure><p>这样便能得到预期的答案  25</p><h2 id="：将宏的参数插入到字符串中"><a href="#：将宏的参数插入到字符串中" class="headerlink" title="#：将宏的参数插入到字符串中"></a>#：将宏的参数插入到字符串中</h2><p>使用#可以使一个宏参数变为对应的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT(VALUE,FORMAT) printf(<span class="meta-string">&quot;the value of &quot;</span> #VALUE <span class="meta-string">&quot; is &quot;</span> FORMAT <span class="meta-string">&quot;\n&quot;</span>,VALUE)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PRINT(i+<span class="number">3</span>, <span class="string">&quot;%d&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图六：</p><p><img src="https://img-blog.csdnimg.cn/c9430b2f7f684210bd780f87bad03b12.PNG#pic_center" alt="在这里插入图片描述"></p><center>图六<center><br><p>可见，#宏参数名 == “宏参数名”，将参数名转化成了一个字符串</p><h2 id="：预处理器粘合剂"><a href="#：预处理器粘合剂" class="headerlink" title="##：预处理器粘合剂"></a>##：预处理器粘合剂</h2><p>使用##可以将宏的参数与其中的内容粘合起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANSWER(NUM,VALUE)\</span></span><br><span class="line"><span class="meta">answer##NUM = VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ANSWER</span><span class="params">(<span class="number">1</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;answer1 = %d\n&quot;</span>, answer1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，answer便与NUM参数的值粘合了起来</p><p>值得一提的是，可以连续多次使用##将更多的参数粘合起来</p><h2 id="宏与函数的对比"><a href="#宏与函数的对比" class="headerlink" title="宏与函数的对比"></a>宏与函数的对比</h2><p>宏与函数的功能貌似有些相近，我们用表一来总结一下宏与函数的异同：<br>|属性|#define定义宏|函数|<br>|–|–|–|<br>|代码长度|每次使用时，宏都会被插入到代码中，除了非常小的宏之外，代码长度会大幅增加|函数的代码只出现在一个地方。每次调用函数，只调用该处的代码|<br>|执行速度|更快|存在函数的调用与返回的额外开销，相对慢一些|<br>|操作符优先级|宏的参数的求值需要结合周围表达式的上下环境，除非加上括号，否则临近操作符的优先级便会出现不可预料的后果，所以建议在宏的书写时加上括号|函数的参数只在传参时求值一次，求值结果传递给函数，不存在参数带来的优先问题级|<br>|带有副作用的参数|参数可能被替换到宏体的多个位置，参数带来的副作用可能会使结果难以预测，如前置++、后置++|函数参数只在传参时求值一次，将结果传递给参数|<br>参数类型|宏的参数与类型无关，只要对参数的操作是合法的，就可以使用任何参数|函数的参数与类型有关，参数类型不同，就要使用不同的参数，即使它们执行的任务是相同的|<br>|调试|宏不便于调试|函数能够逐语句、逐过程调试|<br>|递归|宏不能递归|函数能够递归|</p><center>表一<center><br>## 命名约定<p>我们有这样一个<strong>命名约定</strong>，对于宏名，全部大写；函数名，不要全部大写</p><h2 id="命令行定义"><a href="#命令行定义" class="headerlink" title="命令行定义"></a>命令行定义</h2><p>许多C语言编译器提供了一种能力，允许我们在命令行中定义符号，用于启动编译。</p><p>请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[MAX];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，代码中数组大小 MAX 未定义。该源文件名为test2.c</p><p>在Linux环境下，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -D MAX=100 test2.c</span><br></pre></td></tr></table></figure><p>运行结果如图七：</p><p><img src="https://img-blog.csdnimg.cn/1a4d6a0b454a45acaaca91269a89ac9f.PNG#pic_center" alt="在这里插入图片描述"></p><center>图七<center><br><p>我们成功在命令行中对于MAx进行了定义。</p><h2 id="移除宏定义"><a href="#移除宏定义" class="headerlink" title="移除宏定义"></a>移除宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br></pre></td></tr></table></figure><p>如果我们想对MAX重定义，一种方法是先将MAX移除，再定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br></pre></td></tr></table></figure><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。</p><p>这有利于我们的调试。</p><p>以下是常用的条件编译指令：</p><blockquote><p>1.当 #if 之后的语句为真，执行中间的命令</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 == 1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>2.多分支条件编译</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAX__</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __MIN__</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>3.判断是否被定义/未被定义</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined()</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>4.判断是否未被定义</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined()</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>5.嵌套指令</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">defined</span><span class="params">(OS_UNIX)</span> </span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">ifdef</span> OPTION1</span></span></span><br><span class="line"><span class="function"><span class="title">unix_version_option1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OPTION2 </span></span><br><span class="line">unix_version_option2();</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_MSDOS) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OPTION2</span></span><br><span class="line">msdos_version_option2();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>我们已经知道，#include 指令可以使另外一个文件被编译。</p><p> 这种替换的方式很简单： 预处理器先删除这条指令，并用包含文件的内容替换。 这样一个源文件被包含10次，那就实际被编译10次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “ ” </span></span><br></pre></td></tr></table></figure><p>查找策略：先从自定义目录中寻找头文件，若没找到，去库目录中寻找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; &gt;</span></span></span><br></pre></td></tr></table></figure><p>查找策略：直接去库目录中寻找</p><p>那么，就会出现这样一种情况：一个程序包括了若干个源文件，而其中多个源文件都引用了头文件，这样就会导致嵌套文件的情况发生，如图八：</p><p><img src="https://img-blog.csdnimg.cn/cd882a1ea38c49ffaea5af40402bb836.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图八<center><br><p>game1.c/game1.h与game2.c/game2/h 同时调用了lib.c/lib.h这一公共模块，而test.c/test.h又同时调用了game1.c/game1.h与game2.c/game2/h，所以当test.c编译时，会将lib.c/lib.h中的代码重复编译2次</p><p>解决方案1：<br>每个头文件开头写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __JUD_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __JUD_H__ 100</span></span><br><span class="line">头文件</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>解决方案2：<br>每个头文件开头写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure><h2 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h2><blockquote><p>#error 是一种预编译器指示字，用于生成一个编译错误消息 。</p></blockquote><blockquote><p>用法：#error [message] //message为用户自定义的错误提示信息，可缺省。</p></blockquote><blockquote><p>#error 编译指示字用于自定义编译错误消息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> C++ compiler required.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a id=r1><em>[1] C Primer Plus p521-563</em><a><br><a id=r2><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html"><em>[2] [GCC and Make Compiling, Linking and Building C/C++ Applications</em></a><a> </p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言-7-文件操作</title>
      <link href="/2021/08/17/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%917.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/08/17/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%917.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是文件及文件类型"><a href="#什么是文件及文件类型" class="headerlink" title="什么是文件及文件类型"></a>什么是文件及文件类型</h1><p>文件可以分为<strong>程序文件</strong>和<strong>数据文件</strong>。</p><p>1.<strong>程序文件</strong>，包括源程序文件(.c)、目标文件(windows平台下为.obj)和可执行文件(windows平台下为.exe)<br>2.<strong>数据文件</strong>，包括程序运行时所需要从中读取数据的文件，或者需要向其中写入数据的文件。根据数据的组织形式，数据文件又可以分为<strong>文本文件</strong>和<strong>二进制文件</strong></p><p>我们都知道，数据在内存中以二进制的形式进行存储，如果不加以转换直接输入到外存，这种形式的存储文件就是<strong>二进制文件</strong>；而如果要求数据在外存中以ASCII码的形式存在，则需要在存储前在内存中进行转换，我们说，以ASCII码的形式存储数据的文件就是<strong>文本文件</strong>。</p><p>这就要提到数据在内存中的存储形式了。字符一律以ASCII码的形式存储，而数值型数据既可以是二进制的形式，也可以是ASCII码的形式。</p><p>今有整数<strong>8848</strong>，我们来探究一下<strong>8848</strong>分别以ASCII和二进制的形式在内存中究竟是怎么存储的，请看图一：<br><img src="https://img-blog.csdnimg.cn/ac4f457516214c699c0df0acc0295bf9.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图一</center><br>下面，我们以代码的形式来展示如何将8848以二进制的形式写入到数据文件当中,请看代码一：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码一</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">8848</span>;</span><br><span class="line">FILE* pf = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(fopen);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">fwrite(&amp;num, <span class="keyword">sizeof</span>(num), <span class="number">1</span>, pf);</span><br><span class="line">fclose(pf);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码后，我们首先打开对应的test.txt文件，发现是人类无法读懂的机器码，如图二：</p><p><img src="https://img-blog.csdnimg.cn/5baf77d46e414adc82a355d9d6d5d836.PNG#pic_center" alt="在这里插入图片描述"></p><center>图二</center><br><p>于是，我们用VS2019自带的二进制编辑器打开test.txt文件，如图三、四：</p><p><img src="https://img-blog.csdnimg.cn/e83a2bd65298411382af3d29e47c779f.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><br></p><center>图三</center><br><p><img src="https://img-blog.csdnimg.cn/8d433def261440be94a78ab4ea740f77.PNG#pic_center" alt="在这里插入图片描述"></p><center>图四</center><br>图四中的数是小端存储的16进制数，故为<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00002290</span></span><br></pre></td></tr></table></figure><p>即为十进制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8848</span></span><br></pre></td></tr></table></figure><br><h1 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h1><p>一个文件需要一个唯一的<strong>文件标识</strong>，以便用户识别和引用。</p><p>文件名包含三个部分：文件路径、文件名主干、文件后缀<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\imdan\test.c</span><br></pre></td></tr></table></figure><p>为了方便起见，<strong>文件标识</strong>通常被叫做<strong>文件名</strong><br><br></p><h1 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h1><p>文件缓冲区是用以暂时存放读写期间的文件数据而在内存区预留的一定空间。<br>使用文件缓冲区可减少读取硬盘的次数。<br>文件缓冲区是用以暂时存放读写期间的文件数据而在内存区预留的一定空间。<br>请看图五：<br><img src="https://img-blog.csdnimg.cn/9e89f367768540cea6bc72317c5b7dca.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图五</center><br><h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><p>在C语言中，每个被使用的文件在内存中都会被开辟一块<strong>文件信息区</strong>用来存放这个文件的各种信息（名字，状态，位置等），我们用一个<strong>结构体变量</strong>来保存这些信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">short</span> level;</span><br><span class="line"><span class="keyword">unsigned</span> flags;</span><br><span class="line"><span class="keyword">char</span> fd;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> hold;</span><br><span class="line"><span class="keyword">short</span> bsize;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;</span><br><span class="line"><span class="keyword">unsigned</span> ar *curp;</span><br><span class="line"><span class="keyword">unsigned</span> istemp;</span><br><span class="line"><span class="keyword">short</span> token;</span><br><span class="line">&#125;FILE;</span><br></pre></td></tr></table></figure><p>该结构体被命名为<strong>FILE</strong></p><p>用一个指针变量指向这个文件信息区，这个指针称为<strong>文件指针</strong>。通过文件指针就可对它所指的文件进行各种操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp;</span><br></pre></td></tr></table></figure><p>在这里，fp就是一个文件指针变量，我们通过<strong>fp指针</strong>找到<strong>文件信息区</strong>，通过文件信息区中的信息访问<strong>文件</strong>。也就是说，通过fp能找到我们要访问的文件。如图六：<br><img src="https://img-blog.csdnimg.cn/a32989ee11bf4b5a878f664f2ed2825c.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><center>图六</center><br><h1 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h1><p>我们在读写文件之前应该先<strong>打开文件</strong>，结束之后应该<strong>关闭文件</strong>。</p><p>我们来看函数fopen与fclose的参数与返回值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode )</span></span>;</span><br></pre></td></tr></table></figure><p>对于fopen，我们需要传入的参数是<strong>文件名</strong>（Filename）和 <strong>存取文件的类型</strong>（Type of access permitted），而返回值是一个<strong>FILE*的指针</strong>。特别地，如果打开文件失败，会返回<strong>NULL</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure><p>对于fclose，我们需要传入的参数是<strong>FILE*的指针</strong>，如果关闭文件成功，返回<strong>0</strong>；关闭失败，返回<strong>EOF</strong>。</p><p>下面，让我们来看一下fopen中的第二个参数<strong>mode</strong>究竟有哪些（见表一）</p><table><thead><tr><th>文件使用方式</th><th>含义</th><th>如果指定文件不存在</th></tr></thead><tbody><tr><td>“r”(只读)</td><td>为了输入数据，打开一个已经存在的文本文件</td><td>出错</td></tr><tr><td>“w”(只写)</td><td>为了输出数据，打开一个文本文件</td><td>建立一个新的文件</td></tr><tr><td>“a”(追加)</td><td>向文本文件尾添加数据</td><td>出错</td></tr><tr><td>“rb”(只读)</td><td>为了输出数据，打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb”(只写)</td><td>为了输出数据，打开一个二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab”(追加)</td><td>向一个二进制文件尾添加数据</td><td>出错</td></tr><tr><td>“r+”(读写)</td><td>为了读和写，打开一个文本文件</td><td>出错</td></tr><tr><td>“w+”(读写)</td><td>为了读和写，建立一个新的文件</td><td>建立一个新的文件</td></tr><tr><td>“a+”(读写)</td><td>打开一个文件，在文件尾进行读写</td><td>建立一个新的文件</td></tr><tr><td>“rb+”(读写)</td><td>为了读和写，打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb+”(读写)</td><td>为了读和写建立一个新的二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab+”(读写)</td><td>为了读和写，在文件尾进行读和写</td><td>建立一个新的文件</td></tr></tbody></table><center>表一</center><br>接下来，让我们举一个小例子。我们想把"helloworld"这个字符串写入test.txt的文件中。请看代码二：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码二</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* pf = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(fopen);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;helloworld&quot;</span>, pf);</span><br><span class="line">fclose(pf);</span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件的顺序读写"><a href="#文件的顺序读写" class="headerlink" title="文件的顺序读写"></a>文件的顺序读写</h1><p>下面，我们来介绍一些与文件读写有关的函数（见表二）<br>|功能|函数名|适用范围|定义|<br>|–|–|–|–|<br>|字符输入函数|fgetc|所有输入流|int fgetc( FILE *stream );|<br>|字符输出函数|fputc|所有输出流|int fputc( int c, FILE *stream );|<br>|文本行输入函数|fgets|所有输入流|char *fgets( char *string, int n, FILE *stream );|<br>|文本行输出函数|fputs|所有输出流|int fputs( const char *string, FILE *stream );|<br>|格式化输入函数|fscanf|所有输入流|int fscanf( FILE *stream, const char *format [, argument ]… );|<br>|格式化输出函数|fprintf|所有输出流|int fprintf( FILE *stream, const char *format [, argument ]…);|<br>|从字符串读取格式化输入|sscanf|字符串|int sscanf( const char *buffer, const char *format [, argument ] … );|<br>|将格式化输出写入字符串|sprintf|字符串|int sprintf( char *buffer, const char *format [, argument] … );|<br>|二进制输入|fread|文件|size_t fread( void *buffer, size_t size, size_t count, FILE *stream );|<br>|二进制输出|fwrite|文件|size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream );|</p><center>表二</center><br><h1 id="文件的随机读写"><a href="#文件的随机读写" class="headerlink" title="文件的随机读写"></a>文件的随机读写</h1><p>下面，我们来继续介绍几个有关文件随机读写的函数，<strong>fseek</strong>、<strong>ftell</strong>以及<strong>rewind</strong>。</p><h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h2><blockquote><p>将文件指针移动到指定位置</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">( FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> origin )</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>stream表示流，是一个FILE*的指针<br>offset表示偏移量（单位是字节），1代表向后偏移一个字节，-1代表向前偏移一个字节<br>origin表示起始位置，有三种：<strong>SEEK_CUR</strong>（当前文件指针指向的位置） <strong>SEEK_END</strong>（文件结尾） <strong>SEEK_SET</strong>（文件开头）</p></blockquote><h2 id="ftell"><a href="#ftell" class="headerlink" title="ftell"></a>ftell</h2><blockquote><p>返回当前文件指针的位置，即相对于文件开始时的偏移量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h2><blockquote><p>将文件指针重置到文件开始位置</p></blockquote><p>请看代码三的演示，我们将fseek、ftell、rewind综合使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码三</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//以读写的方式建立新文件</span></span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(fopen);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向文件中写入字符串</span></span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;It is an apple.\n&quot;</span>, fp);</span><br><span class="line"><span class="comment">//重置fp位置，输出文件内容至屏幕</span></span><br><span class="line">rewind(fp);</span><br><span class="line">fgets(arr, <span class="number">18</span>, fp);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;%s&quot;</span>, arr);</span><br><span class="line"><span class="comment">//将fp的位置移动至开头位置后8个字节处，并使用ftell查看此时的偏移量</span></span><br><span class="line">fseek(fp, <span class="number">7</span>, SEEK_SET);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;offset = %d\n&quot;</span>, ftell(fp));</span><br><span class="line"><span class="comment">//在偏移量为8的位置写入字符串，此时覆盖了原本的由此向后的内容</span></span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot; banana.&quot;</span>, fp);</span><br><span class="line"><span class="comment">//重置fp位置，输出文件内容至屏幕</span></span><br><span class="line">rewind(fp);</span><br><span class="line">fgets(arr, <span class="number">25</span>, fp);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s&quot;</span>, arr);</span><br><span class="line"><span class="comment">//关闭文件并将fp置为空指针</span></span><br><span class="line">fclose(fp);</span><br><span class="line">fp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果见图七：<br><img src="https://img-blog.csdnimg.cn/7799ca04a9ca45a885450ad400109010.PNG#pic_center" alt="在这里插入图片描述"></p><center>图七</center><br><h1 id="文件结束判定"><a href="#文件结束判定" class="headerlink" title="文件结束判定"></a>文件结束判定</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>在文件读取结束的时候，我们使用<strong>feof</strong>函数来判断文件是因为<strong>读取失败结束</strong>还是<strong>遇到文件尾结束</strong><br>关于feof的返回值，如果文件正常结束即文件指针指向文件尾，返回<strong>非零值</strong>；如果结束时文件指针没有指向文件结尾，返回<strong>0</strong><br><strong>需要强调的是，feof函数只能用来判断文件是以什么方式结束，而不能用来判断文件是否结束</strong></p></blockquote><blockquote><p>我们能够明白为什么feof不能用来判断文件是否结束，若我们错误地以feof的返回值来判断文件是否结束，若返回值为0，你以为是文件还没有结束，但是若当文件出错结束时，结果就和文件未结束一样，都会返回0</p></blockquote><blockquote><p>所以，我们要用其他方式首先判断文件是否已经结束，然后才能用feof来判断文件究竟以什么方式结束的</p></blockquote><h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><p>文本文件读取是否结束，判断返回值为EOF(fgetc)，或者NULL(fgets)</p><blockquote><p>在文件已经结束时，<strong>fgetc</strong>判断以何种方式结束的方法是判断返回值是否为<strong>EOF</strong>（EOF to indicate an error or end of file）<br>在文件已经结束时，<strong>fgets</strong>判断以何种方式结束的方法是是判断返回值否为<strong>NULL</strong>（NULL is returned to indicate an error or an end-of-file condition.）</p></blockquote><p>请看代码四：</p><blockquote><p>我们事先创建一个test.txt文件，并在其中写入helloworld的内容</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码四</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!fp)</span><br><span class="line">&#123;</span><br><span class="line">perror(fopen);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取test.txt中的字符，遇到文件尾则停止</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((c = fgetc(fp))!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是读取失败结束</span></span><br><span class="line"><span class="keyword">if</span> (ferror(fp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nI/O error when reading\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是遇到文件尾结束</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (feof(fp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nEnd of file reached successfully\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">fp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://img-blog.csdnimg.cn/1b1523fcd53f4a10ac7772464ddeeb49.PNG#pic_center" alt="在这里插入图片描述"></p><center>图八</center><br><h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>二进制文件的读取结束的判断为返回值是否小于实际要读的个数，请看代码五：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">FILE* fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);<span class="comment">//以二进制写的形式打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fp)</span><br><span class="line">&#123;</span><br><span class="line">perror(fopen);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fwrite(arr, <span class="keyword">sizeof</span>(arr), <span class="number">1</span>, fp);<span class="comment">//以二进制形式向文件中写入arr数组</span></span><br><span class="line">fclose(fp);</span><br><span class="line">fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);<span class="comment">//以二进制读的形式打开文件</span></span><br><span class="line"><span class="keyword">while</span>((ret = fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fp)) == <span class="number">1</span>)<span class="comment">//每次读取4个字节的数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是读取失败结束</span></span><br><span class="line"><span class="keyword">if</span> (ferror(fp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nI/O error when reading\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是遇到文件尾结束</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (feof(fp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nEnd of file reached successfully\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">fp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果见图九：<br><img src="https://img-blog.csdnimg.cn/bbccb50b53884c16aa57124fe80d5a15.PNG#pic_center" alt="在这里插入图片描述"></p><center>图九</center><br>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言-6-浮点型在内存中的存储</title>
      <link href="/2021/06/30/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%916.%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>/2021/06/30/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%916.%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在了解到C语言中整型是以二进制补码形式存储在内存中后，我们不禁很好奇：那么浮点型的数据是以什么形式存储在内存中的呢？</p><p>实际上，早在1985年，电气电子工程师学会就制定了IEEE 754标准来解决单精度浮点数在计算机内存中的存储问题。</p><p>那么接下来，我们就以IEEE754-1985版来看一看浮点数在内存中的真实面目。<br><br></p><h1 id="浮点数的表达方式"><a href="#浮点数的表达方式" class="headerlink" title="浮点数的表达方式"></a>浮点数的表达方式</h1><h2 id="浮点数的组成"><a href="#浮点数的组成" class="headerlink" title="浮点数的组成"></a>浮点数的组成</h2><p>浮点型家族中包含有：float、double、long double类型</p><p>IEEE 754标准下，一个浮点数V可以被拆解成三个部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V = (<span class="number">-1</span>) ^ S * f * <span class="number">2</span> ^ E</span><br></pre></td></tr></table></figure><blockquote><ol><li>1-bit sign S —— 符号位S，用来表示正负</li><li>Biased exponent e = E+bias：指数位，负责浮点数的大小</li><li>Fraction f = · b1b2 … bp−1：小数位，负责浮点数的精度，且f大于等于1小于2</li></ol></blockquote><h2 id="单精度浮点数"><a href="#单精度浮点数" class="headerlink" title="单精度浮点数"></a>单精度浮点数</h2><p>对于32位的单精度浮点数而言，内存中32个bit位是这样分配的：</p><ol><li>1位符号位</li><li>8位指数位</li><li>23位小数位</li></ol><p><img src="https://img-blog.csdnimg.cn/20210630201140622.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><br></p><h2 id="双精度浮点数"><a href="#双精度浮点数" class="headerlink" title="双精度浮点数"></a>双精度浮点数</h2><p>对于64位的双精度浮点数而言，内存中64个bit位是这样分配的：</p><ol><li>1位符号位</li><li>11位指数位</li><li>52位小数位<br><img src="https://img-blog.csdnimg.cn/20210630201404549.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>## 指数偏差(Biased Exponent)### 指数E不为全0或全1</li></ol><p>对于float型，我们发现8位的E如果就表示8个无符号的二进制位，那么指数位2^E只能表示比1大的数，而不能表示0-1之间的数，这就导致负指数没法被表示出来。</p><p>为了表示负指数，规定E在内存中的值等于你想要真实表达的指数的值<strong>再加上中间数127（对于double型，这个中间数是1023）</strong>，所以即使你想使用负指数，加上127后E也还是非负的。</p><p><img src="https://img-blog.csdnimg.cn/20210630220608615.PNG#pic_center" alt="在这里插入图片描述"></p><p><strong>这就叫“指数偏差”。</strong><br><br></p><h3 id="指数位E全为1"><a href="#指数位E全为1" class="headerlink" title="指数位E全为1"></a>指数位E全为1</h3><h4 id="小数位-f-不全为0"><a href="#小数位-f-不全为0" class="headerlink" title="小数位 f 不全为0"></a>小数位 f 不全为0</h4><blockquote><p>无论符号位s是什么，浮点数V代表NaN</p></blockquote><p>NaN 是 Not a number 的意思，代表了一个无法被表示出来的值，比如一个数除以0或负数的平方根</p><p><img src="https://img-blog.csdnimg.cn/20210630204502490.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="小数位-f-全为0"><a href="#小数位-f-全为0" class="headerlink" title="小数位 f 全为0"></a>小数位 f 全为0</h4><blockquote><p>浮点数<code>V = ( −1)s∞</code>，此时表示正负无穷大</p></blockquote><h3 id="指数位E全为0"><a href="#指数位E全为0" class="headerlink" title="指数位E全为0"></a>指数位E全为0</h3><p>以下用单精度浮点数为例：</p><h4 id="小数位-f-不全为0-1"><a href="#小数位-f-不全为0-1" class="headerlink" title="小数位 f 不全为0"></a>小数位 f 不全为0</h4><blockquote><p>V = (−1)^s^ * 2^−126^ * (0.f)</p></blockquote><h4 id="小数位-f-全为0-1"><a href="#小数位-f-全为0-1" class="headerlink" title="小数位 f 全为0"></a>小数位 f 全为0</h4><blockquote><p>V = (−1)^s^ * 0 ，此时V表示正负0</p></blockquote><h2 id="小数位的规定（fraction）"><a href="#小数位的规定（fraction）" class="headerlink" title="小数位的规定（fraction）"></a>小数位的规定（fraction）</h2><p><img src="https://img-blog.csdnimg.cn/20210630200547131.PNG#pic_letf" alt="在这里插入图片描述"><br>小数位 f 是一个 [1,2) 间的数，所以 f 可以写成以上图片中的形式：1.xxxxx</p><blockquote><p><strong>由于 f 的第一位总是1，所以我们将第一位的1省略，这样就能多表示一位小数点之后的数了</strong></p></blockquote><h2 id="浮点数的范围"><a href="#浮点数的范围" class="headerlink" title="浮点数的范围"></a>浮点数的范围</h2><p>浮点数的所能表达的最大值/最小值被定义在了头文件&lt;float.h&gt;中</p><p>对于float型：</p><blockquote><p>最小：2^-126^= 1.175×10^-38^<br>最大：2^128^ = 3.403×10^38^</p></blockquote><p>对于double型：</p><blockquote><p>最小：2^-1022^= 2.225×10^-308^<br>最大：2^1024^ = 1.798×10^308^</p></blockquote><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>让我们来看一段代码来进行具体分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">float</span> *pFloat = (<span class="keyword">float</span> *)&amp;n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n的值为：%d\n&quot;</span>,n); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line"></span><br><span class="line">*pFloat = <span class="number">9.0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num的值为：%d\n&quot;</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么运行结果是什么呢？</p><p>不急，我们先对代码进行一波分析。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>我们创建了一个int型变量n并赋值为9</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>我们将一个float型的指针变量pfloat指向了n</p><p>那我们就要问了：整型9在内存中是怎么存储的呢？<br>当然是以补码形式存储，所以这内存中的32个比特位是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span></span><br></pre></td></tr></table></figure><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>我们以%d（有符号整型）形式对上述32个比特位进行打印，显然屏幕上应输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n的值为：<span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>我们以%f（float型）形式对上述32个比特位进行打印</p><p>再看这32个比特位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span></span><br></pre></td></tr></table></figure><p>我们重拾这个公式：<strong>V = (-1) ^ S * f * 2 ^ E</strong> 与 这张图：<br><img src="https://img-blog.csdnimg.cn/20210630211807547.PNG#pic_center" alt="在这里插入图片描述"><br>重新将上述32个比特位排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">00000000</span> <span class="number">00000000000000000001001</span></span><br></pre></td></tr></table></figure><p>故 V = (−1)^s^ * 2^−126^ * (0.00000000000000000001001)<del>2</del>，是一个很小很小的数，所以屏幕上默认打印小数点后六位的话，应输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*pFloat的值为：<span class="number">0.000000</span></span><br></pre></td></tr></table></figure><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>将pfloat指向地址的内容修改为9.0，显然此时上述32个比特位中存储的是单精度浮点数的二进制表达方式，遵循IEEE 754标准</p><p><strong>(9.0)<del>10</del> = (1001.0)<del>2</del> = (1.0010 * 2^3^)<del>2</del></strong></p><p>所以上述32个比特位此时应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">10000010</span> <span class="number">00100000000000000000000</span></span><br></pre></td></tr></table></figure><h2 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h2><p>我们以%d（有符号整型）形式对上述32个比特位进行打印，显然屏幕上应输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num的值为：<span class="number">1</span>,<span class="number">091</span>,<span class="number">567</span>,<span class="number">616</span></span><br></pre></td></tr></table></figure><h2 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h2><p>我们以%f（float型）形式对上述32个比特位进行打印，显然屏幕上应输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*pFloat的值为：<span class="number">9.000000</span></span><br></pre></td></tr></table></figure><p>运行截图如下：<br><img src="https://img-blog.csdnimg.cn/20210630213520340.PNG#pic_left" alt="在这里插入图片描述"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><em><a href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/">1.IEEE Standard 754 Floating Point Numbers</a><em>，</em>geeksforgeeks</em><br><em><a href="https://en.wikipedia.org/wiki/IEEE_754-1985">2.IEEE 754-1985</a><em>，</em>Wikipedia</em><br><em><a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">3.Single-precision floating-point format</a><em>，</em>Wikipedia</em><br><em>4.IEEE Standard for Binary Floating-Point Arithmetic. 1985. <a href="https://ieeexplore.ieee.org/document/30711">doi:10.1109/IEEESTD.1985.82928</a>. ISBN 0-7381-1165-1.</em><br><em>5.<a href="https://en.wikipedia.org/wiki/NaN">NaN</a>，Wikipedia</em></p><p>注：来自维基百科参考文献的快照若有需要，请联系本人</p><p><strong>感谢你们的阅读!本人水平有限，如有错误，还望指正！</strong></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言-5-整型在内存中的存储</title>
      <link href="/2021/06/29/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%915.%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>/2021/06/29/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%915.%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="整型的归类"><a href="#整型的归类" class="headerlink" title="整型的归类"></a>整型的归类</h1><ol><li>char</li><li>short</li><li>int </li><li>long</li></ol><p>以上都分为有符号（signed）与无符号（unsigned）的类型<br></br><br></br></p><h1 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>计算机在表示一个数字时，是采用二进制的方式，所以为了准确表示一个数的正负，每一个有符号数都将其最高位视作是符号位，最高位为0表示正数，最高位为1表示负数。我们接下来以有符号整型int的数字进行分析。</p><p>一个有符号整数由<strong>符号位</strong>+<strong>数值位</strong>组成，数值位是其最高位，分别以0/1表示正/负</p><p>对于正数来说，反码补码都与原码相同；<br>对于负数来说，符合以下3条规则：</p><ol><li>原码：将十进制数字直接翻译为二进制数</li><li>反码：原码的符号位不变，其他位按位取反</li><li>补码：反码+1</li></ol><p>而对于整型来说，整型在内存中实际上是以补码的形式进行存储的。</p><h2 id="补码的意义"><a href="#补码的意义" class="headerlink" title="补码的意义"></a>补码的意义</h2><p>有的同学可能就会问了，为什么计算机要发展出原码、反码、补码这么多种码呢？</p><p>这就与计算机对于整数的运算有关了。</p><p>CPU只有加法器，减法在运算时也会被视作一个数加另一个负数。考虑到整数的最高位是符号位，两个整数中若包含负数，以原码直接相加得到的数一定是不对的。所以问题就变成了如何使得运算简单而精确，既要处理符号位，又要只进行加法运算，达到以某一种二进制形式的“码”直接相加就能得到正确结果。</p><p>下面，我们以60+(-18)为例，分别用原码、反码、补码直接进行二进制的运算。</p><h3 id="原码运算"><a href="#原码运算" class="headerlink" title="原码运算"></a>原码运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00111100</span>（ <span class="number">60</span>的原码）</span><br><span class="line">+ <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00010010</span>（<span class="number">-18</span>的原码）</span><br><span class="line">-------------------------------------------</span><br><span class="line">  <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01001110</span>（某个数的原码）</span><br></pre></td></tr></table></figure><p>显然，得到了的原码转化为10进制是-78，并非正确答案42。</p><h3 id="反码运算"><a href="#反码运算" class="headerlink" title="反码运算"></a>反码运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00111100</span>（ <span class="number">60</span>的反码）</span><br><span class="line">+ <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11101101</span>（<span class="number">-18</span>的反码）</span><br><span class="line">-------------------------------------------</span><br><span class="line"> <span class="number">100000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00101001</span></span><br><span class="line"> 截取后<span class="number">32</span>位：</span><br><span class="line">  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00101001</span>（某个数的反码）</span><br></pre></td></tr></table></figure><p>显然，得到了的反码转化为10进制原码是41，并非正确答案42，但是只与正确答案相差（+1），于是，我们就想将负数的反码+1，即变成“补码”来进行运算，而又正数的补码是原码本身，这时候我们看看会怎么样呢？</p><h3 id="补码运算"><a href="#补码运算" class="headerlink" title="补码运算"></a>补码运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00111100</span>（ <span class="number">60</span>的补码）</span><br><span class="line">+ <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11101110</span>（<span class="number">-18</span>的反码）</span><br><span class="line">-------------------------------------------</span><br><span class="line"> <span class="number">100000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00101010</span></span><br><span class="line"> 截取后<span class="number">32</span>位：</span><br><span class="line">  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00101010</span>（某个数的补码）</span><br></pre></td></tr></table></figure><p>显然，得到了的补码转化为10进制原码是42，我们得到了正确结果。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>综上，我们发现，只要将两个整数使用补码进行运算，就不需要考虑它们的符号位了，将它们的所有位直接简单相加即可，就能得到正确的结果。</strong></p><h2 id="负数二进制补码的快速转化"><a href="#负数二进制补码的快速转化" class="headerlink" title="*负数二进制补码的快速转化"></a>*负数二进制补码的快速转化</h2><p>对于char类型整数，-1用二进制补码表示为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111111</span></span><br></pre></td></tr></table></figure><p>当我们已知一个负数的二进制补码时，用比这个数多一位的、最高位为1、其他位全0、这里应为9位的二进制数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100000000</span></span><br></pre></td></tr></table></figure><p>直接减去-1的二进制补码得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001</span></span><br></pre></td></tr></table></figure><p>得到的数就是十进制（-1）的绝对值，也就是1，只要加上负号，就能快速得到这个负数二进制补码的十进制原码。</p><p>原理十分简单，一个负数的<strong>原码加上补码</strong>  =<strong>原码+反码+1</strong> = <strong>所有二进制位全1再加1</strong> = <strong>多一位的、最高位为1、其他位全0</strong><br></br><br></br></p><h1 id="大小端字节序"><a href="#大小端字节序" class="headerlink" title="大小端字节序"></a>大小端字节序</h1><h2 id="什么是大小端"><a href="#什么是大小端" class="headerlink" title="什么是大小端"></a>什么是大小端</h2><p>在内存中，数据的大小端存储是在<strong>字节</strong>尺度上进行讨论的</p><p>大端存储模式：数据的<strong>低位</strong>保存在内存的<strong>高地址</strong>，数据的<strong>高位</strong>保存在内存的<strong>低地址</strong></p><p>小端存储模式：数据的<strong>低位</strong>保存在内存的<strong>低地址</strong>，数据的<strong>高位</strong>保存在内存的<strong>高地址</strong></p><h2 id="为什么有大端和小端之分"><a href="#为什么有大端和小端之分" class="headerlink" title="为什么有大端和小端之分"></a>为什么有大端和小端之分</h2><p>在计算机系统中，我们通常是以字节为单位存储数据的，每个地址对应一个字节。<br>一个字节为8bit，但是在C语言中除了8bit的char之外，还有16bit的short，32bit的int。另外，对于位数大于8位的处理器，例如16位和32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着如何将多个字节安排的问题。这边导致了大小端存储模式的诞生。<br>我们以int类型的数<strong>0x01ff4218</strong>为例（两个十六进制位即为1个字节），看一下在大小端下这4个字节分别是如何分配的</p><ol><li>大端存储模式<br><img src="https://img-blog.csdnimg.cn/20210629133457391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>小端存储模式<br><img src="https://img-blog.csdnimg.cn/20210629133539470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="写一段代码来判断你的机器的大小端字节序"><a href="#写一段代码来判断你的机器的大小端字节序" class="headerlink" title="写一段代码来判断你的机器的大小端字节序"></a>写一段代码来判断你的机器的大小端字节序</h2>算法简单概括：截取4个字节大小的int整型的1个字节的低位。若机器为大端字节序，该字节存储0x00；若机器为小端字节序，该字节存储0x01；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//实现方法1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">char</span>*)&amp;i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">check</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">&#125;ch = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> ch.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = check1();</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>C Primer Plus, 第六版, p494</li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言-3-枚举类型</title>
      <link href="/2021/06/28/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%913.%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/06/28/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%913.%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>枚举类型(enumerated type)，顾名思义，便是将有可能取到的值一一列举并放入一个集合之中，这个集合便可以视作枚举类型。</p><p>使用enum关键字，可以创建一个新“类型”并指定它可具有的值，这种类型就叫枚举类型。</p><p>例如将一个星期作为集合，它的取值只能是周一到周日，我们便可以使用枚举类型来进行定义，它的语法与结构体类型的语法类似。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="代码1：创建枚举类型"><a href="#代码1：创建枚举类型" class="headerlink" title="代码1：创建枚举类型"></a>代码1：创建枚举类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span>&#123;</span></span><br><span class="line">Monday,</span><br><span class="line">Tuesday,</span><br><span class="line">Wednesday,</span><br><span class="line">Thursday,</span><br><span class="line">Friday,</span><br><span class="line">Saturday,</span><br><span class="line">Sunday</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ol><li>enum Day 这个声明创建了一个Day作为标记名，允许将enum Day作为一个类型名进行使用。</li><li>花括号内的7个标识符枚举了enum Day变量可以取到的所有值。因此，用enum Day创建的变量可以取Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday共7个值。这7个值被称为<strong>枚举符</strong>(enumerator)，又称<strong>枚举常量</strong>，从技术层面上来讲，枚举常量是int类型的常量。同样，枚举常量也可以被理解成为有名称的常量。只要是在能够用到整型常量的地方就能用到枚举常量，<strong>例如定义数组时，数组成员个数就能用枚举常量来带入；switch语句中，case后面的整型常量可以用枚举常量</strong>。<h2 id="代码2：枚举类型的初始化"><a href="#代码2：枚举类型的初始化" class="headerlink" title="代码2：枚举类型的初始化"></a>代码2：枚举类型的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">data</span>&#123;</span></span><br><span class="line">high,</span><br><span class="line">weight,</span><br><span class="line">feture = <span class="number">50</span>,</span><br><span class="line">weath</span><br><span class="line">&#125;element = weight;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; element = %d\n high = %d\n weight = %d\n feture = %d\n weath = %d\n\n\n&quot;</span>, element, high, weight, feture, weath);</span><br><span class="line">element = feture;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; element = %d\n high = %d\n weight = %d\n feture = %d\n weath = %d\n&quot;</span>, element,high,weight,feture,weath);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>运行结果<br><img src="https://img-blog.csdnimg.cn/20210628215556262.PNG#pic_left" alt="在这里插入图片描述"></li></ol><p>分析</p><ol><li>在声明枚举类型时可以进行顺道定义enum data类型的变量element并且可以在主函数中对于element的值进行修改，element的取值仅限于 high, weight, feture, weath, 不能用整数对于element进行赋值，原因在于element的数据类型是 enum data，必须同样用enum data类型的值对它赋值,故不能用int等整型对其赋值</li><li>在声明枚举类型时可以对枚举常量的值进行初始化，如上面的feture=50。若不初始化，默认第一个high数值为0，第二个数值weight为1，以此类推；碰到被人为初始化的值后，其再后面一个枚举常量的值也同样是依次加1，如feture为50，weath为51</li></ol><h1 id="枚举类型的作用"><a href="#枚举类型的作用" class="headerlink" title="枚举类型的作用"></a>枚举类型的作用</h1><p>1.提高程序的可读性和可维护性，用有含义的枚举常量来代替无含义数字<br>2.和#define定义的标识符相比，枚举常量有类型检查，更加严谨<br>3.防止了命名污染<br>4.便于调试<br>5.定义方便，一次可以定义多个常量</p><p><strong>注意</strong>：<br>不能在两个枚举类型中使用相同的枚举常量名称，否则会报出重定义的错误<br><img src="https://img-blog.csdnimg.cn/20210628213923810.PNG#pic_left" alt="在这里插入图片描述"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><em>C Primer Plus，第六版， p474-477</em></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言-1-井字棋</title>
      <link href="/2021/04/24/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%911.%E4%BA%95%E5%AD%97%E6%A3%8B/"/>
      <url>/2021/04/24/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%911.%E4%BA%95%E5%AD%97%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>本算法用于实现井字棋游戏电脑先手情况下的智能落子</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>关于井字棋的模块的搭建，分为<strong>棋盘的初始化</strong>、<strong>棋盘的展示</strong>、<strong>电脑落子</strong>、<strong>玩家落子</strong>、<strong>判断输/赢/平局/继续游戏</strong>这5个模块。</p><p>其中，我们着重介绍一下<strong>电脑落子</strong>的具体算法。本算法可以使得玩家永远赢不了棋局。（输/平局）</p><p>本算法的核心思想为 <strong>暴力枚举</strong> 和 <strong>迫使玩家进行指定位置的落子</strong><br>注：</p><ol><li>本棋盘为3*3的大小</li><li>电脑先手</li><li>以下用形如(2,1)的形式表示落子的坐标</li><li>用“**#<strong>”表示电脑的棋子，用“</strong>***”表示玩家的棋子</li><li>代码部分使用C语言进行实现<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h2>电脑的第一步永远落于(1,1)<br><img src="https://img-blog.csdnimg.cn/2021042421371896.PNG" alt="在这里插入图片描述"></li></ol><h2 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h2><p>接下来，玩家落子一共有8个点可供选择，根据对称性，我们可以将其分分成5组。它们分别是：</p><ol><li>(1,2)或(2.1)</li><li>(1,3)或(3,1)</li><li>(2,3)或(3,2)</li><li>(2,2)</li><li>(3,3)</li></ol><p>以下对于每一类情况进行分组讨论，每组以其中一种情况进行举例<br>蓝色的数字表示落子的顺序</p><h3 id="A-1-2"><a href="#A-1-2" class="headerlink" title="A.(1,2)"></a>A.(1,2)</h3><p><img src="https://img-blog.csdnimg.cn/20210424221729115.PNG" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210424221828727.PNG" alt="在这里插入图片描述"></p><p>上图表示玩家第一手落于(1,2)的情况。此时，显然玩家必输。<br>同理，玩家落子于(2,1)，显然必输。</p><h3 id="B-1-3"><a href="#B-1-3" class="headerlink" title="B. (1,3)"></a>B. (1,3)</h3><p><img src="https://img-blog.csdnimg.cn/20210424215226105.PNG" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210424221926383.PNG" alt="在这里插入图片描述"></p><p>上图表示玩家第一手落于(1,3)的情况。此时，显然玩家必输。<br>同理，玩家落子于(3,1)，显然必输。</p><h3 id="C-2-3"><a href="#C-2-3" class="headerlink" title="C.(2,3)"></a>C.(2,3)</h3><p><img src="https://img-blog.csdnimg.cn/20210424215748500.PNG" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210424222001766.PNG" alt="在这里插入图片描述"></p><p>上图表示玩家第一手落于(2,3)的情况。此时，显然玩家必输。<br>同理，玩家落子于(3,2)，显然必输。</p><h3 id="D-3-3"><a href="#D-3-3" class="headerlink" title="D.(3,3)"></a>D.(3,3)</h3><p><img src="https://img-blog.csdnimg.cn/20210424220110778.PNG" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210424222051838.PNG" alt="在这里插入图片描述"></p><p>上图表示玩家第一手落于(3,3)的情况。此时，显然玩家必输。</p><h3 id="E-2-2"><a href="#E-2-2" class="headerlink" title="E.(2,2)"></a>E.(2,2)</h3><p><img src="https://img-blog.csdnimg.cn/20210424221304623.PNG" alt="在这里插入图片描述"><br>上图表示玩家第一手落于(2,2)的情况。此时，显然最终双方会握手言和。</p><h2 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h2><p>以下展示电脑落子的代码</p><p>首先需定义棋盘大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ROW <span class="number">3</span></span><br><span class="line">#define COL <span class="number">3</span></span><br></pre></td></tr></table></figure><p>首先创建一个3*3的二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> board[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>并将二维数组中每一个元素使用初始化模块初始化为’ ‘ ，也就是空格，此处省略</p><p>我们另需封装一个CountNum函数用来统计棋盘中的9个格子已经有几个格子上落了子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountNum</span><span class="params">(<span class="keyword">char</span> board[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码为具体的电脑落子智能算法，其中参数board表示用来表示棋盘的二维数组的地址，row为ROW（3），col为COL（3）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputerMove</span><span class="params">(<span class="keyword">char</span> board[ROW][COL], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (CountNum(board, ROW, COL) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CountNum(board, ROW, COL) == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5 types , 8 situations</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">2</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CountNum(board, ROW, COL) == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">2</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CountNum(board, ROW, COL) == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1@1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2@1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3@1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4@1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5@1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6@1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7@1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8@1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CountNum(board, ROW, COL) == <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//7@1@1@1</span></span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">2</span>][<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Acknowledgment"><a href="#Acknowledgment" class="headerlink" title="Acknowledgment"></a>Acknowledgment</h1><p>谢谢我自己能在大一下期中考前抽出半天来研究这样一个看似挺无聊的问题</p><p>谢谢小伙伴们能够看完这篇文章</p><p>附上<a href="https://github.com/DanteIoVeYou/C/tree/main/Class_Study_C/2021_4_23_tic_tac_toe%28AI%29">GitHub</a>完整代码</p><p>如果想要深入了解AI对弈，可以去看看极大极小算法（Minimax）</p><p>本人目前水平有限，如有错误，望指正</p><p>2021.4.24  姑苏阴雨绵绵</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言-4-浅谈memcpy与memmove 的区别</title>
      <link href="/2021/03/09/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%914.%E6%B5%85%E8%B0%88memcpy%E4%B8%8Ememmove%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/03/09/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%914.%E6%B5%85%E8%B0%88memcpy%E4%B8%8Ememmove%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="两个函数都包含于-lt-string-h-gt-头文件中"><a href="#两个函数都包含于-lt-string-h-gt-头文件中" class="headerlink" title="两个函数都包含于&lt;string.h&gt;头文件中"></a>两个函数都包含于&lt;string.h&gt;头文件中</h1><h1 id="首先看memcpy函数的定义"><a href="#首先看memcpy函数的定义" class="headerlink" title="首先看memcpy函数的定义"></a>首先看memcpy函数的定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *memcpy( <span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, size_t count );</span><br></pre></td></tr></table></figure><p>dest表示目的地地址，用指针变量加以维护；同理，src表示源地址；count是一个无符号整型，表示将从源地址往后拷贝多少个字节大小的数据</p><h1 id="再看memmove函数的定义"><a href="#再看memmove函数的定义" class="headerlink" title="再看memmove函数的定义"></a>再看memmove函数的定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *memmove( <span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, size_t count );</span><br></pre></td></tr></table></figure><h1 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h1><p>我们发现两者传递的参数相同，而两者之不同，我们现在给出：<br>如果将要拷贝到的目标缓存区与原缓存区有重叠（overlap），则我们需要使用memmove函数；其他情况下，则两者皆可。<br>也就是说，memmove函数支持源缓冲区与目标缓冲区是同一块并且能够处理两者的重叠的情况。</p><p><strong>请看库函数对于memmove函数的算法实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Algorithm:</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> * memmove(<span class="keyword">void</span> * dst, <span class="keyword">void</span> * src, size_t count)</span><br><span class="line">      &#123;</span><br><span class="line">              <span class="keyword">void</span> * ret = dst;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (dst &lt;= src || dst &gt;= (src + count)) &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                       * Non-Overlapping Buffers</span></span><br><span class="line"><span class="comment">                       * copy from lower addresses to higher addresses</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      <span class="keyword">while</span> (count--)</span><br><span class="line">                              *dst++ = *src++;</span><br><span class="line">                      &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                       * Overlapping Buffers</span></span><br><span class="line"><span class="comment">                       * copy from higher addresses to lower addresses</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      dst += count - <span class="number">1</span>;</span><br><span class="line">                      src += count - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">while</span> (count--)</span><br><span class="line">                              *dst-- = *src--;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span>(ret);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><em><strong>以下图中，我们需要将src的四个字符拷贝至dest<br>那么，我们根据src与dest内存地址的相对位置来逐步进行变换<br>我们图中的蓝色箭头表示了从src中拷贝字节的顺序</strong></em></p><ol><li><strong>dest在内存低地址，src在内存高地址，两者没有重叠，我们从前向后对src进行拷贝</strong></li></ol><p><img src="https://img-blog.csdnimg.cn/20210309085943604.PNG#pic_center" alt="在这里插入图片描述"></p><br><br><ol start="2"><li><strong>那么，我们将src稍微向左移动，与dest重叠，此时，就来到了我们的第二种情况，即dest在内存低地址，src在内存高地址，且两者有重叠</strong><br><img src="https://img-blog.csdnimg.cn/20210309090406984.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ol><p><strong>这种情况与第1种情况是一致的。</strong><br><br><br><br></p><ol start="3"><li><strong>那么我们再来看看何时需要从src的高地址向低地址拷贝，也就是src从后向前拷贝给dest的情况</strong><br></li></ol><p><strong>好，我们的src与dest依旧存在重叠，但是与第2种情况不同的是，src位于低地址，dest位于高地址</strong><br><img src="https://img-blog.csdnimg.cn/20210309090920779.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNjQwNjcz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>此时，src从后往前进行拷贝显然是个好方法，避免了未拷贝数据的覆盖。</strong><br><br><br><br><br>4. <strong>我们再把src向左移动，此时，src与dest又没有了内存的重叠。此时从前向后还是从后向前拷贝其实是取决于你的心情了</strong><br><img src="https://img-blog.csdnimg.cn/20210309091922261.PNG#pic_center" alt="在这里插入图片描述"></p><br><br><ol start="5"><li><strong>最后，当我们的src再次向左移动，并且与dest相隔count个字节的距离时，库函数程序员把它归在了对src从前往后进行拷贝的情况</strong><br><img src="https://img-blog.csdnimg.cn/20210309092550455.PNG#pic_center" alt="在这里插入图片描述"></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，是时候进行一下总结了。</p><p>当我们使用<strong>memmove</strong>函数时，<strong>memmove</strong>函数其实已经帮我们考虑到了缓冲区是否重叠的问题了，它允许我们把一个字符串内的内容向它自己进行拷贝。</p><p>而<strong>memcpy</strong>则没有这么贴心了，<strong>memcpy</strong>不会对于重叠的情况加以区别</p><p>但是值得一提的是，如果我们使用VS的编译器，memcpy与memmove的实现方式其实是一致的，两者等价</p><p>我们可以这么说，<strong>memmove</strong>是<strong>memcpy</strong>的升级版，<strong>memmove</strong>是更加安全的。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言-2-结构体类型</title>
      <link href="/2021/03/06/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%912.%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/03/06/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%912.%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体的声明"><a href="#结构体的声明" class="headerlink" title="结构体的声明"></a>结构体的声明</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tag</span>&#123;</span>member-<span class="built_in">list</span>&#125;variable-<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h1 id="结构体的自引用"><a href="#结构体的自引用" class="headerlink" title="结构体的自引用"></a>结构体的自引用</h1><p>结构体能够自引用指向该结构体的指针而不能自引用该结构体本身，否则会出现死递归。</p><h1 id="结构体变量的定义与初始化"><a href="#结构体变量的定义与初始化" class="headerlink" title="结构体变量的定义与初始化"></a>结构体变量的定义与初始化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tag</span>&#123;</span>member-<span class="built_in">list</span>&#125;variable1=&#123; &#125;，variable2=&#123; &#125;;</span><br></pre></td></tr></table></figure><h1 id="技巧：使用typedef在定义结构体时给结构体取别名"><a href="#技巧：使用typedef在定义结构体时给结构体取别名" class="headerlink" title="技巧：使用typedef在定义结构体时给结构体取别名"></a>技巧：使用typedef在定义结构体时给结构体取别名</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">member-<span class="built_in">list</span></span><br><span class="line">&#125;别名;</span><br></pre></td></tr></table></figure><p>之后就“别名”就相当于一个类型名，可以用来定义该类型的变量。</p><h1 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h1><p><strong>性能原因</strong>：用空间来换取时间。<br><strong>平台原因</strong>：某些硬件平台只能在某些地址处取某些特定类型数据，否则抛出硬件异常。</p><p>在设计结构体的时候，既要满足内存对齐，又要节省空间，所以最好把内存小的成员集中在一起。</p><p><strong>计算结构体的大小</strong>：</p><ol><li>Visual C++编译器下，默认对齐值为8。</li><li>第一个成员在与结构体变量偏移量为0的地址处。</li><li>其他成员要对齐到其自身对齐数的整数倍的地址处。</li></ol><p><strong>对齐数</strong>=<font color=red>编译器默认对齐数</font> <strong>与</strong> <font color=red>其自身大小的</font> <strong>较小者</strong>。<br>4. 整个结构体的总大小为最大对齐数的整数倍（每一个成员都有一个最大对其数），可能需要继续浪费内存空间以达到整数倍。<br>5. 如果结构体中嵌套了结构体，嵌套的结构体对齐到它的最大对齐数处，外层结构体的整体大小则为最大对齐数（包含嵌套的对齐数）的整数倍。</p><h1 id="默认对齐数的修改"><a href="#默认对齐数的修改" class="headerlink" title="默认对齐数的修改"></a>默认对齐数的修改</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4) <span class="comment">//设置默认对齐数</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> c1;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack() <span class="comment">//取消设置的默认对齐数</span></span></span><br></pre></td></tr></table></figure><p>在#pragma pack(4)与#pragma pack()之间的代码默认对齐数被设置为了4。</p><h1 id="offsetof宏的使用"><a href="#offsetof宏的使用" class="headerlink" title="offsetof宏的使用"></a>offsetof宏的使用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offsetof(类型名，成员名);</span><br></pre></td></tr></table></figure><p>头文件：&lt;stddef.h&gt;<br>作用：求结构体中某变量相对于首地址的偏移（字节）</p><h1 id="结构体类型传参"><a href="#结构体类型传参" class="headerlink" title="结构体类型传参"></a>结构体类型传参</h1><p>当结构体作为函数参数时，建议传递结构体的地址。<br>有以下几点原因：</p><ol><li>函数传参的时候需要压栈，会有时间和空间上的系统开销</li><li>如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降<h1 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h1>我们可以使用结构体来实现位段，位段的成员是一个或多个位的字段（单位为bit），这些不同长度的字段实际上存储于一个或多个整型变量中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> a:<span class="number">5</span>;</span><br><span class="line"> <span class="keyword">int</span> b:<span class="number">7</span>;</span><br><span class="line"> <span class="keyword">int</span> c:<span class="number">15</span>;</span><br><span class="line"> <span class="keyword">int</span> d:<span class="number">30</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>位段的大小计算：以上面的tag类型结构体为例</strong><br><strong>位段成员必须声明为int，unsigned int，signed int ，short，char等整型家族变量</strong></p><p><strong>位段可以用来节省内存空间，但是有以下的弊端：</strong></p><ol><li>int位段被当作有符号数还是无符号数</li><li>若位段中的最大数目为32，则其无法在16位机器上运行</li><li>位段中的成员在内存中是从左向右还是从右向左分配</li><li>当一个声明指定了两个位段，第2个位段比较大，无法容纳第一个位段的剩余的位时，编译器有可能把第2个位段放在内存的下一个字节，也有可能放在第一个位段后面，这是不确定的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
